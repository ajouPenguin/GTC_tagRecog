Help on module cv2.ml in cv2:

NNAAMMEE
    cv2.ml

FFUUNNCCTTIIOONNSS
    AANNNN__MMLLPP__ccrreeaattee(...)
        ANN_MLP_create() -> retval
        .   @brief Creates empty model
        .   
        .   Use StatModel::train to train the model, Algorithm::load\<ANN_MLP\>(filename) to load the pre-trained model.
        .   Note that the train method has optional flags: ANN_MLP::TrainFlags.
    
    AANNNN__MMLLPP__llooaadd(...)
        ANN_MLP_load(filepath) -> retval
        .   @brief Loads and creates a serialized ANN from a file
        .   *
        .   * Use ANN::save to serialize and store an ANN to disk.
        .   * Load the ANN from this file again, by calling this function with the path to the file.
        .   *
        .   * @param filepath path to serialized ANN
    
    BBoooosstt__ccrreeaattee(...)
        Boost_create() -> retval
        .   Creates the empty model.
        .   Use StatModel::train to train the model, Algorithm::load\<Boost\>(filename) to load the pre-trained model.
    
    BBoooosstt__llooaadd(...)
        Boost_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized Boost from a file
        .   *
        .   * Use Boost::save to serialize and store an RTree to disk.
        .   * Load the Boost from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized Boost
        .   * @param nodeName name of node containing the classifier
    
    DDTTrreeeess__ccrreeaattee(...)
        DTrees_create() -> retval
        .   @brief Creates the empty model
        .   
        .   The static method creates empty decision tree with the specified parameters. It should be then
        .   trained using train method (see StatModel::train). Alternatively, you can load the model from
        .   file using Algorithm::load\<DTrees\>(filename).
    
    DDTTrreeeess__llooaadd(...)
        DTrees_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized DTrees from a file
        .   *
        .   * Use DTree::save to serialize and store an DTree to disk.
        .   * Load the DTree from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized DTree
        .   * @param nodeName name of node containing the classifier
    
    EEMM__ccrreeaattee(...)
        EM_create() -> retval
        .   Creates empty %EM model.
        .   The model should be trained then using StatModel::train(traindata, flags) method. Alternatively, you
        .   can use one of the EM::train\* methods or load it from file using Algorithm::load\<EM\>(filename).
    
    EEMM__llooaadd(...)
        EM_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized EM from a file
        .   *
        .   * Use EM::save to serialize and store an EM to disk.
        .   * Load the EM from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized EM
        .   * @param nodeName name of node containing the classifier
    
    KKNNeeaarreesstt__ccrreeaattee(...)
        KNearest_create() -> retval
        .   @brief Creates the empty model
        .   
        .   The static method creates empty %KNearest classifier. It should be then trained using StatModel::train method.
    
    LLooggiissttiiccRReeggrreessssiioonn__ccrreeaattee(...)
        LogisticRegression_create() -> retval
        .   @brief Creates empty model.
        .   
        .   Creates Logistic Regression model with parameters given.
    
    LLooggiissttiiccRReeggrreessssiioonn__llooaadd(...)
        LogisticRegression_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized LogisticRegression from a file
        .   *
        .   * Use LogisticRegression::save to serialize and store an LogisticRegression to disk.
        .   * Load the LogisticRegression from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized LogisticRegression
        .   * @param nodeName name of node containing the classifier
    
    NNoorrmmaallBBaayyeessCCllaassssiiffiieerr__ccrreeaattee(...)
        NormalBayesClassifier_create() -> retval
        .   Creates empty model
        .   Use StatModel::train to train the model after creation.
    
    NNoorrmmaallBBaayyeessCCllaassssiiffiieerr__llooaadd(...)
        NormalBayesClassifier_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized NormalBayesClassifier from a file
        .   *
        .   * Use NormalBayesClassifier::save to serialize and store an NormalBayesClassifier to disk.
        .   * Load the NormalBayesClassifier from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized NormalBayesClassifier
        .   * @param nodeName name of node containing the classifier
    
    PPaarraammGGrriidd__ccrreeaattee(...)
        ParamGrid_create([, minVal[, maxVal[, logstep]]]) -> retval
        .   @brief Creates a ParamGrid Ptr that can be given to the %SVM::trainAuto method
        .   
        .   @param minVal minimum value of the parameter grid
        .   @param maxVal maximum value of the parameter grid
        .   @param logstep Logarithmic step for iterating the statmodel parameter
    
    RRTTrreeeess__ccrreeaattee(...)
        RTrees_create() -> retval
        .   Creates the empty model.
        .   Use StatModel::train to train the model, StatModel::train to create and train the model,
        .   Algorithm::load to load the pre-trained model.
    
    RRTTrreeeess__llooaadd(...)
        RTrees_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized RTree from a file
        .   *
        .   * Use RTree::save to serialize and store an RTree to disk.
        .   * Load the RTree from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized RTree
        .   * @param nodeName name of node containing the classifier
    
    SSVVMMSSGGDD__ccrreeaattee(...)
        SVMSGD_create() -> retval
        .   @brief Creates empty model.
        .   * Use StatModel::train to train the model. Since %SVMSGD has several parameters, you may want to
        .   * find the best parameters for your problem or use setOptimalParameters() to set some default parameters.
    
    SSVVMMSSGGDD__llooaadd(...)
        SVMSGD_load(filepath[, nodeName]) -> retval
        .   @brief Loads and creates a serialized SVMSGD from a file
        .   *
        .   * Use SVMSGD::save to serialize and store an SVMSGD to disk.
        .   * Load the SVMSGD from this file again, by calling this function with the path to the file.
        .   * Optionally specify the node for the file containing the classifier
        .   *
        .   * @param filepath path to serialized SVMSGD
        .   * @param nodeName name of node containing the classifier
    
    SSVVMM__ccrreeaattee(...)
        SVM_create() -> retval
        .   Creates empty model.
        .   Use StatModel::train to train the model. Since %SVM has several parameters, you may want to
        .   find the best parameters for your problem, it can be done with SVM::trainAuto.
    
    SSVVMM__ggeettDDeeffaauullttGGrriiddPPttrr(...)
        SVM_getDefaultGridPtr(param_id) -> retval
        .   @brief Generates a grid for %SVM parameters.
        .   
        .   @param param_id %SVM parameters IDs that must be one of the SVM::ParamTypes. The grid is
        .   generated for the parameter with this ID.
        .   
        .   The function generates a grid pointer for the specified parameter of the %SVM algorithm.
        .   The grid may be passed to the function SVM::trainAuto.
    
    SSVVMM__llooaadd(...)
        SVM_load(filepath) -> retval
        .   @brief Loads and creates a serialized svm from a file
        .   *
        .   * Use SVM::save to serialize and store an SVM to disk.
        .   * Load the SVM from this file again, by calling this function with the path to the file.
        .   *
        .   * @param filepath path to serialized svm
    
    TTrraaiinnDDaattaa__ccrreeaattee(...)
        TrainData_create(samples, layout, responses[, varIdx[, sampleIdx[, sampleWeights[, varType]]]]) -> retval
        .   @brief Creates training data from in-memory arrays.
        .   
        .   @param samples matrix of samples. It should have CV_32F type.
        .   @param layout see ml::SampleTypes.
        .   @param responses matrix of responses. If the responses are scalar, they should be stored as a
        .   single row or as a single column. The matrix should have type CV_32F or CV_32S (in the
        .   former case the responses are considered as ordered by default; in the latter case - as
        .   categorical)
        .   @param varIdx vector specifying which variables to use for training. It can be an integer vector
        .   (CV_32S) containing 0-based variable indices or byte vector (CV_8U) containing a mask of
        .   active variables.
        .   @param sampleIdx vector specifying which samples to use for training. It can be an integer
        .   vector (CV_32S) containing 0-based sample indices or byte vector (CV_8U) containing a mask
        .   of training samples.
        .   @param sampleWeights optional vector with weights for each sample. It should have CV_32F type.
        .   @param varType optional vector of type CV_8U and size `<number_of_variables_in_samples> +
        .   <number_of_variables_in_responses>`, containing types of each input and output variable. See
        .   ml::VariableTypes.
    
    TTrraaiinnDDaattaa__ggeettSSuubbVVeeccttoorr(...)
        TrainData_getSubVector(vec, idx) -> retval
        .

DDAATTAA
    AANNNN__MMLLPP__BBAACCKKPPRROOPP = 0
    AANNNN__MMLLPP__GGAAUUSSSSIIAANN = 2
    AANNNN__MMLLPP__IIDDEENNTTIITTYY = 0
    AANNNN__MMLLPP__NNOO__IINNPPUUTT__SSCCAALLEE = 2
    AANNNN__MMLLPP__NNOO__OOUUTTPPUUTT__SSCCAALLEE = 4
    AANNNN__MMLLPP__RRPPRROOPP = 1
    AANNNN__MMLLPP__SSIIGGMMOOIIDD__SSYYMM = 1
    AANNNN__MMLLPP__UUPPDDAATTEE__WWEEIIGGHHTTSS = 1
    BBOOOOSSTT__DDIISSCCRREETTEE = 0
    BBOOOOSSTT__GGEENNTTLLEE = 3
    BBOOOOSSTT__LLOOGGIITT = 2
    BBOOOOSSTT__RREEAALL = 1
    BBoooosstt__DDIISSCCRREETTEE = 0
    BBoooosstt__GGEENNTTLLEE = 3
    BBoooosstt__LLOOGGIITT = 2
    BBoooosstt__RREEAALL = 1
    CCOOLL__SSAAMMPPLLEE = 1
    DDTTRREEEESS__PPRREEDDIICCTT__AAUUTTOO = 0
    DDTTRREEEESS__PPRREEDDIICCTT__MMAASSKK = 768
    DDTTRREEEESS__PPRREEDDIICCTT__MMAAXX__VVOOTTEE = 512
    DDTTRREEEESS__PPRREEDDIICCTT__SSUUMM = 256
    DDTTrreeeess__PPRREEDDIICCTT__AAUUTTOO = 0
    DDTTrreeeess__PPRREEDDIICCTT__MMAASSKK = 768
    DDTTrreeeess__PPRREEDDIICCTT__MMAAXX__VVOOTTEE = 512
    DDTTrreeeess__PPRREEDDIICCTT__SSUUMM = 256
    EEMM__CCOOVV__MMAATT__DDEEFFAAUULLTT = 1
    EEMM__CCOOVV__MMAATT__DDIIAAGGOONNAALL = 1
    EEMM__CCOOVV__MMAATT__GGEENNEERRIICC = 2
    EEMM__CCOOVV__MMAATT__SSPPHHEERRIICCAALL = 0
    EEMM__DDEEFFAAUULLTT__MMAAXX__IITTEERRSS = 100
    EEMM__DDEEFFAAUULLTT__NNCCLLUUSSTTEERRSS = 5
    EEMM__SSTTAARRTT__AAUUTTOO__SSTTEEPP = 0
    EEMM__SSTTAARRTT__EE__SSTTEEPP = 1
    EEMM__SSTTAARRTT__MM__SSTTEEPP = 2
    KKNNEEAARREESSTT__BBRRUUTTEE__FFOORRCCEE = 1
    KKNNEEAARREESSTT__KKDDTTRREEEE = 2
    KKNNeeaarreesstt__BBRRUUTTEE__FFOORRCCEE = 1
    KKNNeeaarreesstt__KKDDTTRREEEE = 2
    LLOOGGIISSTTIICC__RREEGGRREESSSSIIOONN__BBAATTCCHH = 0
    LLOOGGIISSTTIICC__RREEGGRREESSSSIIOONN__MMIINNII__BBAATTCCHH = 1
    LLOOGGIISSTTIICC__RREEGGRREESSSSIIOONN__RREEGG__DDIISSAABBLLEE = -1
    LLOOGGIISSTTIICC__RREEGGRREESSSSIIOONN__RREEGG__LL11 = 0
    LLOOGGIISSTTIICC__RREEGGRREESSSSIIOONN__RREEGG__LL22 = 1
    LLooggiissttiiccRReeggrreessssiioonn__BBAATTCCHH = 0
    LLooggiissttiiccRReeggrreessssiioonn__MMIINNII__BBAATTCCHH = 1
    LLooggiissttiiccRReeggrreessssiioonn__RREEGG__DDIISSAABBLLEE = -1
    LLooggiissttiiccRReeggrreessssiioonn__RREEGG__LL11 = 0
    LLooggiissttiiccRReeggrreessssiioonn__RREEGG__LL22 = 1
    RROOWW__SSAAMMPPLLEE = 0
    SSTTAATT__MMOODDEELL__CCOOMMPPRREESSSSEEDD__IINNPPUUTT = 2
    SSTTAATT__MMOODDEELL__PPRREEPPRROOCCEESSSSEEDD__IINNPPUUTT = 4
    SSTTAATT__MMOODDEELL__RRAAWW__OOUUTTPPUUTT = 1
    SSTTAATT__MMOODDEELL__UUPPDDAATTEE__MMOODDEELL = 1
    SSVVMMSSGGDD__AASSGGDD = 1
    SSVVMMSSGGDD__HHAARRDD__MMAARRGGIINN = 1
    SSVVMMSSGGDD__SSGGDD = 0
    SSVVMMSSGGDD__SSOOFFTT__MMAARRGGIINN = 0
    SSVVMM__CC = 0
    SSVVMM__CCHHII22 = 4
    SSVVMM__CCOOEEFF = 4
    SSVVMM__CCUUSSTTOOMM = -1
    SSVVMM__CC__SSVVCC = 100
    SSVVMM__DDEEGGRREEEE = 5
    SSVVMM__EEPPSS__SSVVRR = 103
    SSVVMM__GGAAMMMMAA = 1
    SSVVMM__IINNTTEERR = 5
    SSVVMM__LLIINNEEAARR = 0
    SSVVMM__NNUU = 3
    SSVVMM__NNUU__SSVVCC = 101
    SSVVMM__NNUU__SSVVRR = 104
    SSVVMM__OONNEE__CCLLAASSSS = 102
    SSVVMM__PP = 2
    SSVVMM__PPOOLLYY = 1
    SSVVMM__RRBBFF = 2
    SSVVMM__SSIIGGMMOOIIDD = 3
    SSttaattMMooddeell__CCOOMMPPRREESSSSEEDD__IINNPPUUTT = 2
    SSttaattMMooddeell__PPRREEPPRROOCCEESSSSEEDD__IINNPPUUTT = 4
    SSttaattMMooddeell__RRAAWW__OOUUTTPPUUTT = 1
    SSttaattMMooddeell__UUPPDDAATTEE__MMOODDEELL = 1
    TTEESSTT__EERRRROORR = 0
    TTRRAAIINN__EERRRROORR = 1
    VVAARR__CCAATTEEGGOORRIICCAALL = 1
    VVAARR__NNUUMMEERRIICCAALL = 0
    VVAARR__OORRDDEERREEDD = 0

FFIILLEE
    (built-in)

